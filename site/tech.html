<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
  <head>
    <title>Beehive - A swarm of applications</title>
    <link href="stylesheets/application.css" media="all" rel="stylesheet" type="text/css"/><link href="stylesheets/blackboard.css" media="all" rel="stylesheet" type="text/css"/><link href="stylesheets/idle.css" media="all" rel="stylesheet" type="text/css"/><link href="stylesheets/reset.css" media="all" rel="stylesheet" type="text/css"/><link href="stylesheets/sunburst.css" media="all" rel="stylesheet" type="text/css"/>
    <meta content='text/html;charset=utf-8' http-equiv='Content-Type' />
    <meta content='Ari Lerner' name='author' />
    <script type='text/javascript'>var _gaq = _gaq || [];_gaq.push(['_setAccount', 'UA-8105436-7']);_gaq.push(['_trackPageview']);
    (function() { var ga = document.createElement('script');  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';  ga.setAttribute('async', 'true');  document.documentElement.firstChild.appendChild(ga);})();</script>
  </head>
  <body>
    <div id='header'>
      <a href='/'>
        <!-- %img{:src => "/images/logo2.png", :height => "180"} -->
        <!-- %img{:src => "/images/logo1.png", :height => "180"} -->
        <img height='180' src='/images/site/logo3.png' />
        <h1>
          <span class="emp">Bee</span><span class="unemph">hive</span>
        </h1>
        <h4>
          A swarm of applications
        </h4>
      </a>
      <div id='top'>
        <ul>
          <li class="first"><a href="index.html">Home</a></li>
          <li><a href="documentation.html">Documentation</a></li>
          <li class="last"><a href="community.html">Community</a></li>
        </ul>
      </div>
    </div>
    <div id='content'>
      <div id='left'>
        <h2>Technology</h2>
        <p>
          So how exactly does this work? Beehive is comprised of several systems. There are several layers to the application.
          <pre class="blackboard">  Router&#x000A;<span class="Keyword">|</span>-----------<span class="Keyword">|</span>&#x000A;  Nodes&#x000A;<span class="Keyword">|</span>-----------<span class="Keyword">|</span>&#x000A;  Storage</pre>
        </p>
        <p>
          Each of these layers has their own distinct roles from within beehive.
        </p>
        <h4>Roles</h4>
        <ul class='dots'>
          <li>
            <a href='#router'>
              Router -
            </a>
            responsible for bee registration, client request routing and application/bee notifications
          </li>
          <li>
            <a href='#node'>
              Node -
            </a>
            the hosts where the applications are mounted and hosted
          </li>
          <li>
            <a href='#router'>
              Storage -
            </a>
            responsible for keeping track of the storage locations for the applications, git-repos, squashed bees, etc.
          </li>
        </ul>
        <div id='router'>
          <h3>Router</h3>
        </div>
        <p>
          The routing layer is responsible for client request routing as well as ensuring that applications are reachable, taking appropriate action if they are not.
        </p>
        <p>
          When the routing layer is booted, it connects to a local (and, if given one, a seed's) database. Then it starts the RESTful interface to the backend. If this is successful, it starts the client acceptor process.
          <a href='/images/docs/client_acceptor.png' ><img src='/images/docs/client_acceptor.png' class='doc_image' alt='Client acceptor process' /></a>
        </p>
        <p>
          The acceptor process is a basic tcp listener (implemented using <a href="http://www.erlang.org/doc/man/gen_tcp.html">gen_tcp</a>) that spawns an acceptor process for every request. Additionally, every request has a supervisor that watches the request. If there is an abnormality with the acceptor process, the supervisor will relaunch the accepted process, while the client never sees the problem.
        </p>
        <p>
          When the process has been accepted, the <a href="http://github.com/auser/beehive/blob/master/lib/erlang/src/routing/proxy_handler.erl">proxy_handler</a> takes over control of the socket. It hands off the request to the Beehive protocol handler.
        </p>
        <p>
          The protocol Beehive deals with is abstracted from the decoding of the process so that the proxy can handle any client request that is written for Beehive. Protocol request decoders must export one method called handle_request/1 and must pass back {ok, RoutingKey, ForwardReq, Req}. A plain protocol request decoder template looks like:
          <pre class="blackboard"><span class="Comment"><span class="Comment">%</span>%%-------------------------------------------------------------------</span>&#x000A;<span class="Comment"><span class="Comment">%</span>%% File    : protocol_handler.erl</span>&#x000A;<span class="Comment"><span class="Comment">%</span>%% Author  : Ari Lerner</span>&#x000A;<span class="Comment"><span class="Comment">%</span>%% Description : </span>&#x000A;<span class="Comment"><span class="Comment">%</span>%%   An example protocol_handler</span>&#x000A;<span class="Comment"><span class="Comment">%</span>%% Created :  Thu Dec 10 10:01:12 PST 2009</span>&#x000A;<span class="Comment"><span class="Comment">%</span>%%-------------------------------------------------------------------</span>&#x000A;&#x000A;-<span class="Keyword">module</span> (<span class="Entity">protocol_handler</span>).&#x000A;&#x000A;-<span class="Keyword">include</span> (<span class="String"><span class="String">&quot;</span>beehive.hrl<span class="String">&quot;</span></span>).&#x000A;&#x000A;<span class="Comment"><span class="Comment">%</span>% API</span>&#x000A;-<span class="Keyword">export</span>([&#x000A;  <span class="Entity">handle_request</span>/<span class="Constant">1</span>&#x000A;]).&#x000A;&#x000A;<span class="Entity">handle_request</span>(<span class="Variable">ClientSock</span>) -&gt;&#x000A;  <span class="Variable">Req</span> <span class="Keyword">=</span> <span class="Entity">collect_request</span>(<span class="Variable">ClientSock</span>),&#x000A;  <span class="Variable">Subdomain</span> <span class="Keyword">=</span> <span class="Entity">parse_routing_key</span>(<span class="Variable">Req</span>),&#x000A;  <span class="Variable">ForwardReq</span> <span class="Keyword">=</span> <span class="Entity">build_new_request</span>(<span class="Variable">Req</span>),&#x000A;  {<span class="Constant">ok</span>, <span class="Variable">Subdomain</span>, <span class="Variable">ForwardReq</span>, <span class="Variable">Req</span>}.&#x000A;  &#x000A;<span class="Comment"><span class="Comment">%</span>%--------------------------------------------------------------------</span>&#x000A;<span class="Comment"><span class="Comment">%</span>%% Internal functions</span>&#x000A;<span class="Comment"><span class="Comment">%</span>%--------------------------------------------------------------------</span>&#x000A;<span class="Entity">collect_request</span>(<span class="Variable">ClientSock</span>) -&gt;&#x000A;  <span class="Comment"><span class="Comment">%</span> ...</span></pre>
        </p>
        <p>
          The <a href="http://github.com/auser/beehive/blob/master/lib/erlang/src/request_decoders/http_request_decoder.erl">http request decoder</a> is built-in, so we'll continue talking about that. The http request headers are gathered and parsed by the decoder. The routing key is chosen by the header 'Host,' by default, but this can be overridden in the config (by setting the routing_parameter switch the <a href="http://github.com/auser/beehive/blob/master/lib/erlang/scripts/start_beehive.sh">./start_beehive.sh</a>) script.
        </p>
        <p>
          Once the routing_parameter has been picked off of the request, the proxy_handler attempts to find an available bee for the process to connect. If none is specified, then it chooses the 'base,' which connects to the local RESTful process (defaulting at port 4999) on the router. If there is a subdomain attached, then it first looks to see if an application is registered with the same name. If there is one, then it looks up it's bee_picker
          <div class='term'><a name='bee_picker' class='term-name'>bee_picker</a>
          <div class='term-def'>The bee_picker is the module that picks the bee from the rest. This defaults to the baked-in bee_strategies module, but this can be overridden. More on this later.</div></div>
          And then goes on to pick out the bee_strategy for the app.
          <div class='term'><a name='bee_strategy' class='term-name'>bee_strategy</a>
          <div class='term-def'>The method that the bee_picker uses to pull off the bee. This can be overridden, but defaults to pick a random bee. There are built in ones that can be seen <a href="http://github.com/auser/beehive/blob/master/lib/erlang/src/mesh/router/bee_strategies.erl">here</a>.</div></div>
        </p>
        <p>
          Once the parameters are chosen, a bee is chosen. Only available bees are sent into the bee_picker, so if there are no available bees, then an empty array will be sent in.
        </p>
        <div id='node'>
          <h3>Node</h3>
        </div>
        <div id='storage'>
          <h3>Storage</h3>
        </div>
        <p>
          More technical details about the system can be found on the
          <a href="http://github.com/auser/beehive/tree/master/lib/erlang/">readme</a>
        </p>
      </div>
      <div id='right'>
        
        <h3>Quickstart</h3>
        <pre class="blackboard">git clone http://github.com/auser/beehive.git&#x000A;cloud start -c config/clouds.rb</pre>
        <h3>Links</h3>
        <ul>
          <li class="first"><a href="http://github.com/auser/beehive">Github</a></li>
          <li class="last"><a href="http://github.com/auser/beehive/wikis">Wiki</a></li>
        </ul>
      </div>
      <div class='clear'>&nbsp;</div>
      <div id='footer'>
        <p>
          Copyright &copy; 2009 - Ari Lerner and Cloudteam at AT&T Interactive
          <a href="sitemap.html">sitemap</a>
        </p>
      </div>
    </div>
  </body>
</html>
